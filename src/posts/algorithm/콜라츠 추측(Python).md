---
title: "#26 알고리즘 연습 - 콜라츠 추측 (Python)"
date: "2019-05-06"
category: ['algorithm']
draft : False
---

1937년 Collatz란 사람에 의해 제기된 이 추측은, 
주어진 수가 1이 될때까지 다음 작업을 반복하면, 
모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.

1. 입력된 수가 짝수라면 2로 나눕니다. 
2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다.
3. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다.

 
예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다.
위 작업을 몇 번이나 반복해야하는지 반환하는 함수, solution을 완성해 주세요. 
단, 작업을 500번을 반복해도 1이 되지 않는다면 –1을 반환해 주세요.


제한 사항

입력된 수, num은 1 이상 8000000 미만인 정수입니다.


입출력 예

|n	|result|
|-|-|
|6	|8|
|16	|4|
|626331	|-1|


입출력 예 설명

입출력 예 #1
문제의 설명과 같습니다.

입출력 예 #2
16 -> 8 -> 4 -> 2 -> 1 이되어 총 4번만에 1이 됩니다.

입출력 예 #3
626331은 500번을 시도해도 1이 되지 못하므로 -1을 리턴해야합니다.


>__*문제풀이*__   
홀수 일때 짝수 일때 숫자를 가공하는 것은 그렇게 어려운 부분이 아닌데
해당 로직을 계속 이용해야하므로 Recursive를 생각할 수 있다.   
그런데 Recursive를 사용하기에는 함수가 하나 더 필요하고 cnt를 구분해서 밖으로 빼기에도 귀찮아지므로
무한루프를 이용하고 특정 조건일때 return으로 함수가 종료되도록 해주자



#### 내 풀이 🏆
```python

def solution(num):
    cnt = 0                  #연산이 이루어질때마다 count를 해주기 위해 cnt설정
    while True:              #while cnt < 500 이런 조건을 걸어 줄 수도 있겠지만 특정 조건하에서

                              return으로 함수(물론 반복문도) 탈출할 수 있으므로 True 조건을 줘도 된다
        if num ==1:
            return cnt       #return을 하게 되면 while뿐만 아니라 함수가 종료된다
        elif cnt >= 500:     #num의 연산이 이루어지기 전에 조건을 검사해서 탈출 시켜야 한다면 탈출 시키자
            return -1
        elif num%2 == 0:     
            cnt += 1
            num= num/2
        else:
            cnt += 1
            num = num*3 +1

```

+ while이 아니라 for 문을 이용할 수도 있는데 500 이라는 limit가 걸려있기 때문에

`for i in range(500)`이런식으로 작성을 해주게 되면
cnt 를 따로 선언하지 않아도 return에서 i로 반복문을 몇번이나 돌아 갔는지 확인해줄수 있다.