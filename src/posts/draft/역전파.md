---
title: 'ì˜¤ì°¨ì—­ì „íŒŒë²•'
date: '2020-06-21'
category: []
draft: True
---

4ì¥ì—ì„œëŠ” ìˆ˜ì¹˜ë¯¸ë¶„ì„ ì´ìš©í•´ì„œ êµ¬í˜„ì„ í–ˆëŠ”ë° **ìˆ˜ì¹˜ë¯¸ë¶„ì€ ë‹¨ìˆœí•˜ê³  êµ¬í˜„ì´ ì‰½ì§€ë§Œ ì‹œê°„ì´ ì˜¤ë˜** ê±¸ë¦°ë‹¤. ë”°ë¼ì„œ **ì˜¤ì°¨ì—­ì „íŒŒë²•(ì—­ì „íŒŒ)**(`backpropagation`) ì„ ì´ìš©í•´ì„œ êµ¬í˜„í•´ë³´ë„ë¡í•˜ì

### ğŸ‘ˆ backpropagation

ìˆ˜ì‹ì„ í†µí•œ ì´í•´ì™€ ê³„ì‚° ê·¸ë˜í”„ë¥¼ í†µí•œ ì´í•´ê°€ ìˆë‹¤.

### ê³„ì‚°ê·¸ë˜í”„

ê³„ì‚°ê³¼ì •ì„ **_ê·¸ë˜í”„ ìë£Œêµ¬ì¡°_**ë¡œ ë‚˜íƒ€ë‚¸ê²ƒìœ¼ë¡œ `node` ì™€ `edge` ë¡œ í‘œí˜„í•œë‹¤.

> ì‚¬ê³¼ --100ì›--> X2(ë…¸ë“œ) --200--> x1.1(ë…¸ë“œ) --220-->

ì´ì²˜ëŸ¼ **nodeì•ˆì— ì—°ì‚°ë‚´ìš©**ì´ ë“¤ì–´ê°€ê³  **edgeë¥¼ í†µí•´ì„œ data**ê°€ ì›€ì§ì¸ë‹¤.

ì´ë•Œ ê·¸ë˜í”„ì—ì„œ ê³„ì‚°ì„ ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì§„í–‰í•˜ëŠ” ê²ƒì„ ìˆœì „íŒŒë¼ í•œë‹¤.
ë°˜ëŒ€ë°©í–¥ìœ¼ë¡œëŠ” ì—­ì „íŒŒë¼í•˜ê³  ë¯¸ë¶„ì„ ê³„ì‚°í• ë•Œ ì¤‘ìš”í•œ ì—­í• ì„ í•œë‹¤.

ê³„ì‚°ê·¸ë˜í”„ëŠ” **_êµ­ì†Œì  ê³„ì‚°ì„ í†µí•´ì„œ ìµœì¢…ê²°ê³¼ë¥¼ ë„ì¶œ_**í•´ ë‚¸ë‹¤.
ê° ë…¸ë“œëŠ” ìì‹ ê³¼ ì—°ê´€ëœ ê³„ì‚° ì™¸ì—ëŠ” ì‹ ê²½ì“¸ í•„ìš”ê°€ ì—†ë‹¤.

-   êµ­ì†Œì  ê³„ì‚°ì„ í†µí•´ ê° ë¬¸ì œì— ì§‘ì¤‘í•¨ìœ¼ë¡œ ë‹¨ìˆœí™”ì‹œí‚¬ìˆ˜ìˆë‹¤.
-   ì¤‘ê°„ ê³„ì‚° ê²°ê³¼ë¥¼ ëª¨ë‘ ë³´ê´€í• ìˆ˜ ìˆë‹¤.
-   ì—­ì „íŒŒë¥¼ í†µí•´ ë¯¸ë¶„ì„ íš¨ìœ¨ì ìœ¼ë¡œ ê³„ì‚°í• ìˆ˜ ìˆë‹¤.

ìˆœì „íŒŒì˜ ë°˜ëŒ€ í™”ì‚´í‘œë¥¼ êµµì€ì„ ìœ¼ë¡œ ê·¸ë¦¬ê³  ì•„ë˜ì— ë¯¸ë¶„ê°’ì„ ì ì–´ ë¹„(ratio)ë¥¼ ë³¼ìˆ˜ìˆë‹¤.

### ì—°ì‡„ë²•ì¹™

ì—­ì „íŒŒê°€ êµ­ì†Œ ë¯¸ë¶„ì„ ì „ë‹¬í•˜ëŠ” ì›ë¦¬ëŠ” `chain Rule`ì— ë”°ë¥¸ê²ƒì´ë‹¤.

í•©ì„±í•¨ìˆ˜ : ì—¬ëŸ¬í•¨ìˆ˜ë¡œ ë¶„ë¦¬í•´ ë‚˜íƒ€ë‚¼ìˆ˜ìˆëŠ” í•¨ìˆ˜

```python
z = (x+y)^2
#ìœ„ì˜ ì‹ì€ ì•„ë˜ì™€ ê°™ì´ ë¶„ë¦¬í• ìˆ˜ìˆë‹¤.
z = t^2
t = x+y
```

í•©ì„±í•¨ìˆ˜ì˜ ë¯¸ë¶„ì€ **_í•©ì„±í•¨ìˆ˜ë¥¼ êµ¬ì„±í•˜ëŠ” ê° í•¨ìˆ˜ì˜ ë¯¸ë¶„ì˜ ê³±_**ìœ¼ë¡œ ë‚˜íƒ€ë‚¼ìˆ˜ìˆë‹¤.(ë¯¸ë¶„í‘œê¸°ì˜ ê³±ì…ˆìœ¼ë¡œ ë‚˜íƒ€ë‚´ì¤„ìˆ˜ ìˆë‹¤ëŠ” ë§)`dt/dy*dy/dx`

ì—°ì‡„ë²•ì¹™ì€ ì–´ë µê²Œ ìƒê°í•  í•„ìš”ì—†ì´ ë‚´ê°€ í•„ìš”í•œ í•¨ìˆ˜ë¥¼ ë¶„í• í•´ì„œ ì—¬ëŸ¬ í•¨ìˆ˜ì˜ ê³±ìœ¼ë¡œ ë‚˜íƒ€ë‚¼ìˆ˜ ìˆëŠ”ê²ƒì´ë‹¤.

---

### ì—­ì „íŒŒ

ë§ì…ˆì˜ ì—­ì „íŒŒëŠ” ê·¸ëŒ€ë¡œ ì „ë‹¬í•´ì£¼ê¸°ë•Œë¬¸ì— ìˆœì „íŒŒì˜ ì…ë ¥ì‹ í˜¸ê°€ í•„ìš”ì—†ì—ˆëŠ”ë°
ì—­ì „íŒŒëŠ” **_ë‹¤ë¥¸ ì…ë ¥ì‹ í˜¸ì˜ ê°’ì„ ê³±í•´ì•¼í•˜ë¯€ë¡œ ìˆœë°©í–¥ ì…ë ¥ì‹ í˜¸ì˜ ê°’ì´ í•„ìš”í•´ì„œ ì €ì¥_** í•´ë‘”ë‹¤.

### ë‹¨ìˆœí•œ ê³„ì¸µ êµ¬í˜„í•˜ê¸°

ë‹¤ìŒ ì ˆì—ì„œëŠ” **_ì‹ ê²½ë§ì„ êµ¬ì„±í•˜ëŠ” ê³„ì¸µ(ê³„ì¸µì´ë‘ ì‹ ê²½ë§ì˜ ê¸°ëŠ¥ë‹¨ìœ„)ì„ classë¡œ êµ¬í˜„í•œë‹¤._**

ëª¨ë“  ê³„ì¸µì€ `forward()`(ìˆœì „íŒŒ)ì™€ `backward()`(ì—­ì „íŒŒ)ë¼ëŠ” ê³µí†µì˜ method, ì¸í„°í˜ì´ìŠ¤ë¥¼ ê°–ë„ë¡ êµ¬í˜„í• ê²ƒì´ë‹¤.

-   `ê³±ì…ˆê³„ì¸µ` : ê³±ì…ˆê³„ì¸µì€ ì—­ì „íŒŒë¡œ **_ëŒì•„ê°ˆë•Œ ì…ë ¥ì‹ í˜¸ì˜ ìƒëŒ€ê°’ì´ í•„ìš”_**í•˜ë¯€ë¡œ ì €ì¥í•´ë†“ëŠ”ë‹¤.
-   `ë§ì…ˆê³„ì¸µ` : ë§ì…ˆê³„ì¸µì€ ì—­ì „íŒŒë¡œ ëŒì•„ê°ˆë•Œ ê·¸ëƒ¥ ë³´ë‚´ì¤˜ë„ ë˜ë‹ˆê¹Œ initìœ¼ë¡œ xì™€ yë¥¼ ë”°ë¡œ ì´ˆê¸°í™”í•´ì„œ ì €ì¥í•´ì£¼ì§€ ì•ŠëŠ”ë‹¤.

ìœ„ì™€ ê°™ì€ ë°©ë²•ìœ¼ë¡œ ê³„ì‚°ê·¸ë˜í”„ë¥¼ ì´ìš©í•˜ë©´ ë³µì¡í•œ ë¯¸ë¶„ë„ ì†ì‰½ê²Œ í• ìˆ˜ ìˆë‹¤.
(ê³„ì‚°ê·¸ë˜í”„ì—ì„œ ì—°ì‡„ë²•ì¹™ì„ ì´ìš©í•˜ì—¬ ì—­ì „íŒŒë¥¼ êµ¬í•´ë†¨ìœ¼ë©´ í•´ë‹¹ dataê°€ ì¶œë ¥ê°’ì— ì–¼ë§ˆë§Œí¼ì˜ ì˜í–¥ì„ ë¯¸ì¹˜ëŠ”ì§€ í™•ì¸í•´ì¤„ ìˆ˜ ìˆë‹¤.==>ì¦‰ ë¯¸ë¶„ê³¼ ê°™ì´ ë³€í™”ìœ¨ì— ëŒ€í•´ì„œ êµ¬í•  ìˆ˜ ìˆë‹¤.)

### í™œì„±í™” í•¨ìˆ˜ ê³„ì¸µ êµ¬í˜„í•˜ê¸°

ì‹ ê²½ë§ì„ êµ¬ì„±í•˜ëŠ” ê³„ì¸µì„ ê°ê° í•˜ë‚˜ì˜ í´ë˜ìŠ¤ë¡œ êµ¬í˜„í•œë‹¤.

### ReLU ê³„ì¸µ êµ¬í˜„í•˜ê¸°

-   ReLUì˜ ìˆ˜ì‹

```
y = x (x>0)
y = 0 (x<=0)
```

-   ReLUì˜ ë¯¸ë¶„ì‹

```
dy/dx = 1 (x>0)
dy/dv = 0 (x<=0)
```

> ë”°ë¼ì„œ ìœ„ì˜ ì‹ì„ ë³´ë©´ ìˆœì „íŒŒì˜ ì…ë ¥ì´ 0ì´í•˜ë©´ ì—­ì „íŒŒë¡œ ëŒì•„ê°ˆë•Œ í•˜ë¥˜ë¡œ ì‹ í˜¸ë¥¼ ë³´ë‚´ì§€ ì•ŠëŠ”ë‹¤. ì…ë ¥ì´ 0ì´ìƒì´ë©´ ê·¸ëŒ€ë¡œ ì „í•´ì¤€ë‹¤.

```python
class Relu:
    def __init__(self):
        self.mask = None

    def forward(self, x):
        # xëŠ” ë„˜íŒŒì´ ë°°ì—´ë¡œ ë“¤ì–´ì˜¤ëŠ”ë° xê°€ 0ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì€ indexë¥¼ Trueë¡œ í•˜ì—¬ ë°°ì—´ìƒì„±
        self.mask = (x <= 0)
        out = x.copy()
        out[self.mask] = 0  # 0ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì€ ì• ë“¤ì´ Trueì´ë¯€ë¡œ ê·¸ indexì— í•´ë‹¹í•˜ëŠ” eleë¥¼ 0ìœ¼ë¡œ ë°”ê¿ˆ

        return out

    # ì—­ì „íŒŒëŠ” ìˆœì „íŒŒë•Œ ë§Œë“  maskë¥¼ ì´ìš©í•´ì„œ Trueì¸ indexì— ëŒ€í•´ì„œ doutì„ 0ìœ¼ë¡œ ì „ë‹¬í•œë‹¤.
    def backward(self, dout):
        dout[self.mask] = 0
        dx = dout

        return dx
```

### sigmoid

```
y = 1 / (1+exp(-x))
```

ì—°ì‚° ë…¸ë“œì˜ ìˆœì„œë¥¼ ë³´ë©´

`x --> exp --> + --> /` ì‹ìœ¼ë¡œ ë‚˜ë‰˜ì–´ì§„ë‹¤.
ì—­ì „íŒŒ ìˆœì„œëŒ€ë¡œ ì˜¤ë¥¸ìª½ --> ì™¼ìª½ìœ¼ë¡œ ì—­í–‰í•˜ë©´ì„œ sigmoidì˜ ì—­ì „íŒŒë¥¼ í•œë²ˆ êµ¬í˜„í•´ë³´ì

1. `/` ë…¸ë“œ ë¯¸ë¶„( y = 1/x )
   `dy/dx = -(1/x^2) = -y^2`

ë”°ë¼ì„œ í•´ë‹¹ ë…¸ë“œë¥¼ ì§€ë‚˜ë©´ ìƒë¥˜ì—ì„œ í˜ëŸ¬ë“¤ì–´ì˜¨ ê°’ì— `-y^2`ì„ ê³±í•´ì„œ í•˜ë¥˜ë¡œ ë³´ë‚¸ë‹¤

2. `+` ë…¸ë“œ
   ë³„ë‹¤ë¥¸ ì‘ì—…ì—†ì´ í•˜ë¥˜ë¡œ ë³´ë‚¸ë‹¤(ê·¸ëŒ€ë¡œ ì „ë‹¬)

3. `exp` ë…¸ë“œ(y=e^x)
   `dy/dx = e^x`

ë”°ë¼ì„œ 1ì—ì„œ ê³±í•´ì§„ ê°’ì— ë”í•´ì„œ`e^x`ë¥¼ ê³±í•´ì„œ ì „í•´ì¤€ë‹¤.

4.  `x` ë…¸ë“œ
    ìˆœì „íŒŒ ë•Œ ì…ë ¥ë°›ì€ ê°’ì„ ì„œë¡œ ë°”ê¿” ê³±í•˜ë¯€ë¡œ
    ì—¬ê¸°ì„œëŠ” -1ì´ ìˆœì „íŒŒë•Œ ë‹¤ë¥¸ ì…ë ¥ìœ¼ë¡œ ì£¼ì–´ì¡Œìœ¼ë¯€ë¡œ `-1`ì„ ê³±í•˜ë©´ ëœë‹¤.

5.  ìµœì¢…ì¶œë ¥
    `dL/dy(y^2*e^-x)`

    ì…ë ¥ê°’ì¸ xì™€ ì¶œë ¥ê°’ì¸ yë§Œìœ¼ë¡œ ê³„ì‚°ì´ ë˜ê³  ì¤‘ê°„ê³¼ì •ì„ ëª¨ë‘ ë¬¶ì–´ `sigmoid node`ë¼ëŠ” ì—­ì „íŒŒ ë…¸ë“œ í•˜ë‚˜ë¡œ ëŒ€ì²´í•´ë²„ë¦´ìˆ˜ ìˆë‹¤.

    (ì´ëŸ´ë•Œ ì¤‘ê°„ê³¼ì •ì„ ìƒëµí•˜ì—¬ ë³´ë‹¤ íš¨ìœ¨ì ì´ê¸°ë„ í•˜ì§€ë§Œ ê·¸ë£¹í™” í•´ì„œ ì™¸ë¶€ì— ë‚´ìš©ì„ ë…¸ì¶œí•˜ì§€ ì•ŠëŠ”ê²ƒë„ ì¤‘ìš”í¬ì¸íŠ¸ë¡œ ì‘ìš©í•œë‹¤.)

    `dL/dy(y^2*e^-x)` = `dL/dy(y*(1-y))`

    ìœ„ì˜ ì‹ìœ¼ë¡œ ë°”ê¿”ì„œ ê³„ì‚°í• ìˆ˜ ìˆëŠ”ë° ì´ëŠ” **ì¶œë ¥(y)**ë§Œìœ¼ë¡œë„ ê³„ì‚°í• ìˆ˜ ìˆë‹¤ëŠ” ë§ì´ ëœë‹¤. ê·¸ë¦¬ê³  ì´ë¥¼ ì´ìš©í•´ì„œ `backward`ë¥¼ êµ¬í˜„í•œë‹¤.

#### Affine/Softmax ê³„ì¸µ êµ¬í˜„í•˜ê¸°

ì‹ ê²½ë§ì˜ ìˆœì „íŒŒì—ì„œ ìˆ˜í–‰í•˜ëŠ” í–‰ë ¬ì˜ ê³±ì„ ê¸°í•˜í•™ì—ì„œ `affine transformation`ì´ë¼ê³  í•œë‹¤.

ë”°ë¼ì„œ Affienë³€í™˜ì„ ìˆ˜í–‰í•˜ëŠ” ì²˜ë¦¬ë¥¼ Affineê³„ì¸µìœ¼ë¡œ êµ¬í˜„í•œë‹¤.

ì´ë•Œ ì—­ì „íŒŒë¥¼ êµ¬í•  ë•Œë„ í–‰ë ¬ì— ëŒ€ì‘í•˜ëŠ” **ì°¨ì›ì˜ ì›ì†Œìˆ˜ê°€ ì¼ì¹˜í•˜ë„ë¡** ê³±ì„ ì¡°ë¦½í•˜ì—¬ êµ¬í•œë‹¤.

#### Softmax - with - Loss ê³„ì¸µ

ì¶œë ¥ì¸µì—ì„œ ì‚¬ìš©í•˜ëŠ”`softmax`í•¨ìˆ˜ì— ëŒ€í•´ì„œ ì•Œì•„ë³´ì
softmaxëŠ” ì…ë ¥ê°’ì„ ì •ê·œí™”(ì´ëŠ” ì´í•©ì´ 1ë¡œ í™•ë¥ ë¡œ ë‚˜íƒ€ë‚œë‹¤)í•´ì„œ ì¶œë ¥í•œë‹¤.

> ì‹ ê²½ë§ì„ í•™ìŠµì‹œí‚¬ë•ŒëŠ” **_softmaxí•¨ìˆ˜ë¡œ ì •ê·œí™”_** í•´ì¤˜ì•¼í•˜ëŠ”ë°, ì‹ ê²½ë§ì„ ì´ìš©í•´ ì¶”ë¡ í•˜ëŠ” ê³¼ì •ì—ì„œ ë‹µì„ í•˜ë‚˜ë§Œ ë‚´ëŠ” ê²½ìš°ì—ëŠ” ê°€ì¥ ë†’ì€ ì ìˆ˜ë§Œ ì•Œë©´ ë˜ë¯€ë¡œ **_êµ³ì´ softmaxí•¨ìˆ˜ë¥¼ ì“¸ í•„ìš”ëŠ” ì—†ë‹¤_**. ì™œëƒí•˜ë©´ sortingëœ ìˆœì„œëŠ” ê°™ê²Œ ì›€ì§ì´ê¸° ë•Œë¬¸ì´ë‹¤.

`softmax` ê³„ì¸µì˜ ì—­ì „íŒŒëŠ” `(y1-t1, y2-t2)`ì™€ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ë§ë”í•œ ê²°ê³¼ë¥¼ ë³´ì—¬ì£¼ëŠ”ë° ì´ë•Œì˜ yëŠ” softmaxê³„ì¸µì˜ ì¶œë ¥ì´ê³  tëŠ” ì •ë‹µ ë ˆì´ë¸”ì´ë¯€ë¡œ ì¶œë ¥ê³¼ ì •ë‹µì˜ **ì°¨ë¶„ì´ ì•ê³„ì¸µìœ¼ë¡œ ì „í•´ì§€ëŠ” ê²ƒ**ì´ë‹¤.

ì‹ ê²½ë§ì˜ ëª©ì ì€ **ì‹ ê²½ë§ì˜ ì¶œë ¥(softmaxì˜ ì¶œë ¥)**ì´ ì •ë‹µê³¼ ê°€ê¹Œì›Œì§€ë„ë¡ ê°€ì¤‘ì¹˜ ë§¤ê°œë³€ìˆ˜ë¥¼ ì¡°ì •í•˜ëŠ”ê²ƒì´ë‹¤. ë”°ë¼ì„œ íš¨ìœ¨ì ìœ¼ë¡œ ì•ìœ¼ë¡œ ì „ë‹¬í•´ì•¼í•œë‹¤.

ì—­ì „íŒŒë¡œ ìœ„ì™€ê°™ì€ ëª¨ì–‘ì´ ë‚˜ì˜¤ëŠ” ì´ìœ ëŠ” êµì°¨ ì—”íŠ¸ë¡œí”¼ ì˜¤ì°¨í•¨ìˆ˜ê°€ í¸í•˜ê²Œ ì „í•´ì£¼ë„ë¡ ì„¤ê³„ê°€ ë˜ì–´ìˆê¸°ë•Œë¬¸ì´ë‹¤.
ì´ì™€ ê°™ì€ ì›ë¦¬ë¡œ í•­ë“±í•¨ìˆ˜ì˜ ì†ì‹¤í•¨ìˆ˜ë¡œ ì˜¤ì°¨ì œê³±í•©ì„ í•˜ëŠ” ì´ìœ ë„ ë§ë”íˆ ë–¨ì–´ì§€ê²Œ ì„¤ê³„í•´ë†”ì„œì´ë‹¤.

### ì˜¤ì°¨ì—­ì „íŒŒë²•(backpropagation) êµ¬í˜„

ì´ëŸ¬í•œ ê³„ì¸µë“¤ì„ ì¡°í•©í•˜ë©´ ë ˆê³ ì¡°ë¦½í•˜ë“¯ ì‹ ê²½ë§ì„ êµ¬ì¶•í• ìˆ˜ìˆë‹¤. ì˜¤ì°¨ì—­ì „íŒŒë²•ì´ ë“±ì¥í•˜ëŠ” ë‹¨ê³„ëŠ” ê¸°ìš¸ê¸° ì‚°ì¶œë‹¨ê³„ì—ì„œ ì ìš©í•´ì¤„ìˆ˜ìˆëŠ”ë°
ê¸°ì¡´ì˜ ìˆ˜ì¹˜ë¯¸ë¶„ì— ë¹„í•´ì„œ **_íš¨ìœ¨ì ì´ê³  ë¹ ë¥´ê²Œ ì—°ì‚°_**ì„ í•´ì¤„ìˆ˜ìˆë‹¤.

ì´ë²ˆ ì¥ì—ì„œ ê° ê³„ì¸µì„ ëª¨ë“ˆí™”í•´ì„œ ë§Œë“¤ì–´ë†¨ê¸°ë•Œë¬¸ì— ì—¬ëŸ¬ì¸µì´ë”ë¼ë„ íš¨ìœ¨ì ìœ¼ë¡œ êµ¬í˜„í• ìˆ˜ ìˆë‹¤.

### ê¸°ìš¸ê¸° ê²€ì¦í•˜ê¸°

1.  ìˆ˜ì¹˜ë¯¸ë¶„ì„ ì¨ì„œ êµ¬í•˜ëŠ” ë°©ë²•
2.  í•´ì„í•™ì  ë°©ë²•(ì˜¤ì°¨ì—­ì „íŒŒë²•)

ë³€í™”ìœ¨ì„ êµ¬í•˜ëŠ” ë°©ë²•ì—ëŠ” 1ë²ˆê³¼ 2ë²ˆì˜ ë°©ë²•ì´ ìˆëŠ”ë° 2ë²ˆì„ êµ¬í˜„í•´ë†“ìœ¼ë©´ 1ë²ˆì€ ì„±ëŠ¥ìƒ ì“¸ëª¨ê°€ ì—†ì„ì§€ë„ ëª¨ë¥´ì§€ë§Œ **_1ë²ˆë°©ë²•ì´ êµ¬í˜„ì´ ì‰¬ìš°ë¯€ë¡œ ìš°ë¦¬ëŠ” 1ë²ˆì„ í†µí•´ì„œ 2ë²ˆì„ ê²€ì¦_**í•˜ë„ë¡ í•œë‹¤.

### ì •ë¦¬

ê³„ì‚°ê·¸ë˜í”„ì˜ **_ìˆœì „íŒŒëŠ” í†µìƒì˜ ê³„ì‚°_**ì„ í•˜ê³ 
ê³„ì‚°ê·¸ë˜í”„ì˜ **_ì—­ì „íŒŒëŠ” ê° ë…¸ë“œì˜ ë¯¸ë¶„_**ì„ êµ¬í• ìˆ˜ ìˆë‹¤.

### ğŸ‘¨â€ğŸ’»ì‹¤ìŠµì½”ë“œ

```python
class MulLayer:
    # ê°ì²´ë³€ìˆ˜ì¸ xì™€ yë¥¼ ì´ˆê¸°í™”í•œë‹¤.
    def __init__(self):
        self.x = None
        self.y = None

    def forward(self, x, y):
        self.x = x
        self.y = y
        out = x*y
        return out

    def backward(self, dout):
        dx = dout*self.y
        dy = dout * self.x
        return dx, dy

# ì‚¬ê³¼ ì˜ˆì œë¥¼ MulLayerë¥¼ ì‚¬ìš©í•˜ì—¬ í’€ì–´ë³´ê¸°


# apple = 100
# apple_num = 2
# tax = 1.1

# mul_apple_layer = MulLayer()
# mul_tax_layer = MulLayer()
# apple_price = mul_apple_layer.forward(apple, apple_num)
# price = mul_tax_layer.forward(apple_price, tax)

# print(price)

# # ê° ë³€ìˆ˜ì— ëŒ€í•œ ë¯¸ë¶„ì€ backwardì—ì„œ êµ¬í•˜ì

# dprice = 1
# dapple_price, dtax = mul_tax_layer.backward(dprice)
# dapple, dapple_num = mul_apple_layer.backward(dapple_price)

# print(dapple, dapple_num, dtax)
# backward()ê°€ ë°›ëŠ” ì¸ìˆ˜ëŠ” ìˆœì „íŒŒì˜ ì¶œë ¥ì— ëŒ€í•œ ë¯¸ë¶„


class AddLayer:
    # ë§ì…ˆê³„ì¸µì€ x, yê°€ êµ³ì´ í•„ìš”ì—†ìœ¼ë‹ˆ initì´ ì•„ë¬´ì¼ë„ í•˜ì§€ì•ŠëŠ”ë‹¤
    def __init__(self):
        pass

    def forward(self, x, y):
        out = x+y
        return out

    # backward() ì—ì„œëŠ” ì¶œë ¥ìœ¼ë¡œë¶€í„° ëŒì•„ì˜¤ëŠ” ê°’ì„ ê·¸ë˜ë„ ë‹¤ì‹œ í˜ë ¤ë³´ë‚¸ë‹¤
    # ìƒë¥˜ -> í•˜ë¥˜ë¡œ
    def backward(self, dout):
        dx = dout * 1
        dy = dout * 1
        return dx, dy


apple = 100
apple_num = 2
orange = 150
orange_num = 3
tax = 1.1

# ê³„ì¸µë“¤
mul_apple_layer = MulLayer()
mul_orange_layer = MulLayer()
add_apple_orange_layer = AddLayer()
mul_tax_layer = MulLayer()

apple_price = mul_apple_layer.forward(apple, apple_num)
orange_price = mul_orange_layer.forward(orange, orange_num)

all_price = add_apple_orange_layer.forward(apple_price, orange_price)
price = mul_tax_layer.forward(all_price, tax)

dprice = 1
dall_price, dtax = mul_tax_layer.backward(dprice)
dapple_price, dorange_price = add_apple_orange_layer.backward(dall_price)
dorange, dorange_num = mul_orange_layer.backward(dorange_price)
dapple, dapple_num = mul_apple_layer.backward(dapple_price)

print(price)
print(dapple_num, dapple, dorange, dorange_num, dtax)


class Relu:
    def __init__(self):
        self.mask = None

    def forward(self, x):
        # xëŠ” ë„˜íŒŒì´ ë°°ì—´ë¡œ ë“¤ì–´ì˜¤ëŠ”ë° xê°€ 0ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì€ indexë¥¼ Trueë¡œ í•˜ì—¬ ë°°ì—´ìƒì„±
        self.mask = (x <= 0)
        out = x.copy()
        out[self.mask] = 0  # 0ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì€ ì• ë“¤ì´ Trueì´ë¯€ë¡œ ê·¸ indexì— í•´ë‹¹í•˜ëŠ” eleë¥¼ 0ìœ¼ë¡œ ë°”ê¿ˆ

        return out

    # ì—­ì „íŒŒëŠ” ìˆœì „íŒŒë•Œ ë§Œë“  maskë¥¼ ì´ìš©í•´ì„œ Trueì¸ indexì— ëŒ€í•´ì„œ doutì„ 0ìœ¼ë¡œ ì „ë‹¬í•œë‹¤.
    def backward(self, dout):
        dout[self.mask] = 0
        dx = dout

        return dx

# ReLUëŠ” ì „í˜•ì ì¸ ì „ê¸°íšŒë¡œ ë¬¸ì œì™€ ë¹„ìŠ·í•˜ë‹¤ ì „ë¥˜ê°€ íë¥¼ë•ŒëŠ” ì „ë¥˜ë¥¼ í˜ë ¤ë³´ë‚´ê³ 
# ìŠ¤ìœ„ì¹˜ê°€ êº¼ì§€ë©´ ì „ë¥˜ê°€ ì•„ì˜ˆ ì•ˆí˜ëŸ¬ê°€ëŠ”


class Sigmoid:
    def __init__(self):
        self.out = None

    # ìˆœì „íŒŒì˜ ì¶œë ¥ì„ outì— ë³´ê´€í•˜ë‹¤ê°€ ì—­ì „íŒŒ ê³„ì‚°ë•Œ ê°’ì„ ì‚¬ìš©í•œë‹¤.
    def forward(self, x):
        out = 1/(1+np.exp(-x))
        self.out = out

        return out

    def backward(self, dout):
        dx = dout * (1.0 - self.out)*self.out

        return dx


class Affine:
    def __init__(self, W, b):
        self.W = W
        self.b = b
        self.x = None
        self.dW = None
        self.db = None

    def forward(self, x):
        self.x = x
        out = np.dot(x, self.W) + self.b
        return out

    def backward(self, dout):
        dx = np.dot(dout, self.W.T)
        self.dW = np.dot(self.x.T, dout)
        self.db = np.sum(dout, axis=0)

        return dx


class SoftmaxWithLoss:
    def __init__(self):
        self.loss = None  # ì†ì‹¤
        self.y = None  # softmaxì˜ ì¶œë ¥
        self.t = None  # ì •ë‹µë ˆì´ë¸”(ì›í•«ì¸ì½”ë”©)

    def forward(self, x, t):
        self.t = t
        self.y = softmax(x)
        self.loss = cross_entropy_error(self.y, self.t)
        return self.loss

    def backward(self, dout=1):
        batch_size = self.t.shape[0]

        # ì—­ì „íŒŒë¡œ ì „íŒŒí•˜ëŠ” ê°’ì„ ë°°ì¹˜ì˜ ìˆ˜ë¡œ ë‚˜ëˆ  data1ê°œë‹¹ ì˜¤ì°¨ë¥¼ ì•ìœ¼ë¡œ ì „íŒŒ
        dx = (self.y - self.t) / batch_size

        return dx

```
